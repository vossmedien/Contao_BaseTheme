{# Twig Template für das Auction Filter Modul #}
<div class="container">
    <div class="auction-filter-module">
        {# Filter-Formular #}
        <div class="filter-container card mb-4">
            <div class="card-header bg-light">
                <h3 class="mb-0">{{ 'Filter'|trans }}</h3>
            </div>
            <div class="card-body">
                {# ACHTUNG: Der Controller muss die Variablen 'filter_configs', 'options' und 'filters' bereitstellen! #}
                {# 'filter_configs': Array mit Konfiguration für jeden Filter (key, label, type, options_key/min/max/step) #}
                {# 'options': Array mit den Select-Optionen (Schlüssel entspricht 'options_key' aus filter_configs) #}
                {# 'filters': Array mit den aktuell angewendeten Filterwerten aus dem Request #}
                <form class="auction-filter" method="get">
                    <div class="row mb-3 filter-row"> {# Wrapper-Reihe für Filter #}
                        {% for key, config in filter_configs|default([]) %}
                            {% set filter_value = filters[key]|default(null) %}
                            {% set filter_value_min = filters[key ~ '_min']|default(null) %}
                            {% set filter_value_max = filters[key ~ '_max']|default(null) %}

                            {% if config.type == 'select' %}
                                <div class="col-md-6 mb-3 filter-item-{{ key }}">
                                    <label for="{{ key }}" class="form-label">{{ config.label|trans }}</label>
                                    <select name="{{ key }}" id="{{ key }}" class="form-select">
                                        <option value="">{{ config.placeholder|trans|default('Alle') }}</option>
                                        {% set select_options = options[config.options_key]|default([]) %}
                                        {% for option_value, option_label in select_options %}
                                            <option value="{{ option_value }}" {% if filter_value == option_value %}selected{% endif %}>
                                                {{ option_label|trans }} {# Annahme: Labels sind entweder übersetzbar oder bereits übersetzt #}
                                            </option>
                                        {% endfor %}
                                    </select>
                                </div>

                            {% elseif config.type == 'range_slider' %}
                                {# Alte Methode mit <input type="range"> #}
                                {% set min_cfg = config.min|default(0) %}
                                {% set max_cfg = config.max|default(100) %}
                                {% set step_cfg = config.step|default(1) %} 
                                {# Der Wert des Sliders repräsentiert hier den Max-Wert, Min ist implizit 0 oder der konfigurierte Min-Wert #}
                                {# Wenn ein Max-Wert im Filter gesetzt ist, nehmen wir den, sonst den Max-Wert der Config #}
                                {% set current_slider_value = filter_value_max|default(max_cfg) %}
                                {# Die Anzeige zeigt Min-Filter bis Max-Filter oder den vollen Bereich #}
                                {% set display_min = filter_value_min|default(min_cfg) %}
                                {% set display_max = filter_value_max|default(max_cfg) %}

                                <div class="col-md-6 mb-4 filter-item-{{ key }}"> {# Use col-md-6 for sliders too for better layout #}
                                    <label class="form-label">{{ config.label|trans }}: <span id="{{ key }}-range-value">{{ display_min }} - {{ display_max }}</span></label>
                                    <div class="d-flex align-items-center">
                                         <input type="range" class="form-range" id="{{ key }}-range"
                                             min="{{ min_cfg }}"
                                             max="{{ max_cfg }}"
                                             step="{{ step_cfg }}"
                                             value="{{ current_slider_value }}"> {# Der Wert des Sliders ist der Max-Wert #}
                                    </div>
                                     <div class="d-flex justify-content-between">
                                        {# Versteckte Felder für Min/Max-Werte - werden vom JS befüllt #}
                                        <input type="hidden" name="{{ key }}_min" id="{{ key }}_min" value="{{ filter_value_min|default('') }}">
                                        <input type="hidden" name="{{ key }}_max" id="{{ key }}_max" value="{{ filter_value_max|default('') }}">
                                        {# Min/Max Labels anzeigen #}
                                         <small>{{ min_cfg }}</small>
                                         <small>{{ max_cfg }}</small>
                                     </div>
                                </div>

                            {% endif %}
                         {% endfor %}
                    </div> {# Ende der .filter-row #}

                    {# Buttons bleiben statisch #}
                    <div class="d-flex gap-2 flex-wrap filter-buttons mt-3">
                        <button type="submit" class="btn btn-primary">
                            <i class="bi bi-funnel"></i> {{ 'Filtern'|trans }}
                        </button>
                        <a href="{{ app.request.pathInfo }}" class="btn btn-secondary">
                            <i class="bi bi-x-circle"></i> {{ 'Zurücksetzen'|trans }}
                        </a>
                        <button type="submit" name="refresh" value="1" class="btn btn-success">
                            <i class="bi bi-arrow-clockwise"></i> {{ 'Daten aktualisieren'|trans }}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>


{# JavaScript für AJAX-Filter und HTML5 Range Slider (alte Methode) #}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Filter-Formular finden
    const filterForm = document.querySelector('.auction-filter');
    if (!filterForm) return;

    // Referenz auf das Listing-Element und "Keine Auktionen"-Nachricht
    const auctionItems = document.querySelector('.auction-items'); // Muss im Haupt-Template existieren
    const noAuctions = document.querySelector('.no-auctions');     // Muss im Haupt-Template existieren

    // Range-Slider initialisieren (alte Methode)
    initRangeSliders();

    // Loading-Overlay erstellen (falls noch nicht vorhanden)
    let loadingOverlay = document.querySelector('.loading-overlay');
    if (!loadingOverlay) {
        loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'loading-overlay';
        loadingOverlay.innerHTML = '<div class="spinner"></div><div class="loading-text">{{ 'Daten werden geladen...'|trans }}</div>';
        const filterModule = document.querySelector('.auction-filter-module');
        if (filterModule) {
           filterModule.style.position = 'relative';
           filterModule.appendChild(loadingOverlay);
        }
    }

    // FormData in serialisierbares Objekt umwandeln (für History API) - Angepasst für alte Slider-Logik
    function formDataToObject(formData) {
        const object = {};
        formData.forEach((value, key) => {
            // Speichere nur, wenn der Wert nicht leer ist
            if (value !== '') {
                 // Wenn der Wert bereits existiert, mache ein Array daraus (für Multi-Select etc.)
                 if (object.hasOwnProperty(key)) {
                     if (!Array.isArray(object[key])) {
                         object[key] = [object[key]];
                     }
                     object[key].push(value);
                 } else {
                     object[key] = value;
                 }
            }
        });

        // Füge Min/Max-Werte für Range Slider hinzu, basierend auf den hidden Inputs
        filterForm.querySelectorAll('input[type="range"]').forEach(slider => {
            const baseKey = slider.id.replace('-range', '');
            const minInput = document.getElementById(baseKey + '_min');
            const maxInput = document.getElementById(baseKey + '_max');
            if (minInput && minInput.value !== '') {
                if (!object[baseKey]) object[baseKey] = {};
                object[baseKey].min = minInput.value;
            }
            if (maxInput && maxInput.value !== '') {
                 if (!object[baseKey]) object[baseKey] = {};
                 object[baseKey].max = maxInput.value;
            }
             // Entferne leere Range-Slider Objekte
             if (object[baseKey] && typeof object[baseKey] === 'object' && Object.keys(object[baseKey]).length === 0) {
                 delete object[baseKey];
             }
        });

        return object;
    }

    // AJAX-Filter-Funktion (leicht angepasst für alte Slider-Logik)
    function ajaxFilter(formData, pushState = true) {
        if(loadingOverlay) loadingOverlay.style.display = 'flex';

        const cleanedFormData = new FormData();
        for (const [key, value] of formData.entries()) {
            if (value !== '') {
                cleanedFormData.append(key, value);
            }
        }

        const params = new URLSearchParams(cleanedFormData);
        const currentPath = window.location.pathname;
        const queryString = params.toString();
        const newUrl = currentPath + (queryString ? '?' + queryString : '');

        if (pushState) {
            const stateObject = formDataToObject(formData); // Nutzt die angepasste Funktion
            history.pushState({ formData: stateObject }, '', newUrl);
        }

        fetch(newUrl, {
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response.text();
            })
            .then(html => {
                console.log('AJAX success, processing response...'); // Log 1
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // --- Update Filter Area --- Only update the row with filters ---
                console.log('Updating filter area (row only)...'); // Log 2
                const newFilterBody = doc.querySelector('.filter-container .card-body'); // Find in response
                const currentFilterBody = document.querySelector('.filter-container .card-body'); // Find in current DOM

                if (newFilterBody && currentFilterBody) {
                     const newFilterRow = newFilterBody.querySelector('.filter-row');
                     const currentFilterRow = currentFilterBody.querySelector('.filter-row');
                     if (newFilterRow && currentFilterRow) {
                        currentFilterRow.innerHTML = newFilterRow.innerHTML;
                        console.log('Filter row HTML replaced. Re-initializing sliders...'); // Log 3
                        // WICHTIG: HTML5 Range Slider neu initialisieren!
                        initRangeSliders(); // Form listener should persist
                        console.log('Sliders re-initialized.'); // Log 4
                     } else {
                         console.warn('Could not find new or current filter row.');
                     }
                } else {
                    console.warn('Could not find new or current filter body.');
                }

                // --- Update Auction Listing Area (remains the same) ---
                console.log('Updating listing area...'); // Log 5
                const newAuctionItems = doc.querySelector('.auction-items');
                const newNoAuctions = doc.querySelector('.no-auctions');

                if (auctionItems && newAuctionItems && newAuctionItems.innerHTML.trim() !== '') {
                    auctionItems.innerHTML = newAuctionItems.innerHTML;
                    auctionItems.style.display = newAuctionItems.style.display || 'flex';
                    if (noAuctions) noAuctions.style.display = 'none';
                } else if (noAuctions && newNoAuctions) {
                    if (auctionItems) auctionItems.style.display = 'none';
                    noAuctions.innerHTML = newNoAuctions.innerHTML;
                    noAuctions.style.display = newNoAuctions.style.display || 'block';
                } else {
                     console.warn("Konnte weder '.auction-items' noch '.no-auctions' im AJAX-Response finden.");
                     if (auctionItems) auctionItems.innerHTML = '';
                     if (noAuctions) noAuctions.style.display = 'none';
                }
                console.log('Listing area updated.'); // Log 6

                if(loadingOverlay) loadingOverlay.style.display = 'none';
                console.log('AJAX processing complete.'); // Log 7
            })
            .catch(error => {
                console.error('Filter-Fehler:', error);
                if(loadingOverlay) loadingOverlay.style.display = 'none';
                // window.location.href = newUrl; // Entfernt: Kein automatischer Redirect bei AJAX-Fehler
                // Optional: Zeige dem Benutzer eine Fehlermeldung an
                // alert('Beim Laden der Filterergebnisse ist ein Fehler aufgetreten. Bitte versuchen Sie es erneut.');
            });
    }

    // Event Listener für das Absenden des Formulars
    filterForm.addEventListener('submit', function(event) {
        const clickedButton = event.submitter;
         if (!clickedButton || clickedButton.name !== 'refresh') {
            event.preventDefault();
            // Sicherstellen, dass Min/Max-Werte der Slider aktuell sind vor dem Senden
            updateHiddenInputsFromSliders();
            const formData = new FormData(filterForm);
            ajaxFilter(formData, true);
         }
    });

    // Event Listener für den Reset-Button (aus altem Code übernommen)
     const resetButton = filterForm.querySelector('a[href="' + window.location.pathname + '"]');
     if (resetButton) {
         resetButton.addEventListener('click', function(e) {
             e.preventDefault();
             filterForm.reset(); // Setzt Standard-Formularfelder zurück

             // Range-Slider auf Config-Max zurücksetzen und Hidden Inputs leeren
             filterForm.querySelectorAll('input[type="range"]').forEach(slider => {
                  const max = slider.getAttribute('max') || 0; // Max-Wert holen
                  slider.value = max; // Slider auf Max setzen (JS-Verhalten anpassen)

                  const baseKey = slider.id.replace('-range', '');
                  const minInput = document.getElementById(baseKey + '_min');
                  const maxInput = document.getElementById(baseKey + '_max');
                  if(minInput) minInput.value = ''; // Min leeren
                  if(maxInput) maxInput.value = ''; // Max leeren

                  // Init-Funktion für den einzelnen Slider aufrufen, um Anzeige zu aktualisieren
                  const configMin = slider.getAttribute('min') || 0;
                  const configMax = slider.getAttribute('max') || 0;
                  const valueDisplayId = baseKey + '-range-value';
                   if (minInput && maxInput && document.getElementById(valueDisplayId)) {
                       // Rufe Update-Logik direkt auf oder simuliere Event
                       updateValueDisplay(slider, minInput, maxInput, document.getElementById(valueDisplayId), configMin, configMax);
                   }
             });


             // Zum ursprünglichen URL zurückkehren (ohne Parameter)
             history.pushState({}, '', window.location.pathname);

             // AJAX-Anfrage für die ungefilterten Daten (mit leerer FormData)
             ajaxFilter(new FormData()); // Leere FormData senden
         });
     }


    // Zurück/Vorwärts-Navigation im Browser behandeln (angepasst für alte Slider)
    window.addEventListener('popstate', function(event) {
        if (event.state && event.state.formData) {
            const storedFormData = event.state.formData;

            // Formular zurücksetzen
            filterForm.reset();

             // Standardfelder füllen
             Object.entries(storedFormData).forEach(([key, value]) => {
                 // Range Slider Min/Max nicht direkt setzen
                 if (!key.endsWith('_min') && !key.endsWith('_max')) {
                     const field = filterForm.querySelector(`[name="${key}"]`);
                     if (field) field.value = value;
                 }
             });

             // Range Slider und Hidden Inputs aktualisieren
             filterForm.querySelectorAll('input[type="range"]').forEach(slider => {
                  const baseKey = slider.id.replace('-range', '');
                  const minVal = storedFormData[baseKey + '_min'] || '';
                  const maxVal = storedFormData[baseKey + '_max'] || '';
                  const configMax = slider.getAttribute('max');

                  const minInput = document.getElementById(baseKey + '_min');
                  const maxInput = document.getElementById(baseKey + '_max');
                  if(minInput) minInput.value = minVal;
                  if(maxInput) maxInput.value = maxVal;

                  // Slider-Position setzen (auf Max-Wert, wenn vorhanden, sonst Config-Max)
                  slider.value = maxVal !== '' ? maxVal : configMax;

                  // Anzeige aktualisieren
                   const configMin = slider.getAttribute('min') || 0;
                   const valueDisplayId = baseKey + '-range-value';
                    if (minInput && maxInput && document.getElementById(valueDisplayId)) {
                        updateValueDisplay(slider, minInput, maxInput, document.getElementById(valueDisplayId), configMin, configMax);
                    }
             });

            // AJAX-Anfrage senden (ohne History Push)
            ajaxFilter(new FormData(filterForm), false);

        } else {
            // Fallback, wenn kein State vorhanden ist (z.B. initiale Seite oder manueller Reset)
             // Einfach die Seite neu laden oder leere Filter anwenden
              // window.location.reload();
               filterForm.reset(); // Formular leeren
               initRangeSliders(); // Slider auf Default setzen
               ajaxFilter(new FormData()); // Leere Filter anwenden
        }
    });

    // --- Initialisierung und Handling für HTML5 Range Slider (alte Methode) ---

    function initRangeSliders() {
         filterForm.querySelectorAll('input[type="range"]').forEach(slider => {
             const baseKey = slider.id.replace('-range', '');
             const minInput = document.getElementById(baseKey + '_min');
             const maxInput = document.getElementById(baseKey + '_max');
             const valueDisplay = document.getElementById(baseKey + '-range-value');
             const min = parseFloat(slider.getAttribute('min') || 0);
             const max = parseFloat(slider.getAttribute('max') || 0);

              if (!slider || !minInput || !maxInput || !valueDisplay) {
                  console.error("Missing elements for HTML5 range slider:", baseKey);
                  return;
              }

             // Initiale Anzeige aktualisieren basierend auf hidden inputs
             updateValueDisplay(slider, minInput, maxInput, valueDisplay, min, max);

              // Slider-Wert beim Laden setzen (auf Max-Wert aus Input, sonst Config-Max)
              slider.value = maxInput.value !== '' ? maxInput.value : max;


              // Event-Listener für den Slider
              slider.addEventListener('input', function() {
                  updateHiddenInputsAndDisplay(slider, minInput, maxInput, valueDisplay, min, max);
              });

              // Optional: AJAX-Filter bei Loslassen des Sliders auslösen
              slider.addEventListener('change', function() {
                   updateHiddenInputsFromSliders(); // Sicherstellen, dass Inputs aktuell sind
                   // const formData = new FormData(filterForm);
                   // ajaxFilter(formData, true);
              });
         });
    }

    function updateHiddenInputsAndDisplay(slider, minInput, maxInput, valueDisplay, min, max) {
         const sliderValue = parseFloat(slider.value);

          // Logik der alten Methode: Min ist immer der Config-Min, Max ist der Slider-Wert
          // Nur wenn Slider NICHT auf Max steht, wird gefiltert
          if (sliderValue < max) {
              minInput.value = min; // Min ist der konfigurierte Minimalwert
              maxInput.value = sliderValue; // Max ist der aktuelle Sliderwert
          } else {
              // Wenn Slider auf Max steht, Filter zurücksetzen (leere Inputs)
              minInput.value = '';
              maxInput.value = '';
          }

         // Anzeige aktualisieren
         updateValueDisplay(slider, minInput, maxInput, valueDisplay, min, max);
    }

     function updateValueDisplay(slider, minInput, maxInput, valueDisplay, min, max) {
         let displayMin, displayMax;

         // Logik der alten Methode: Wenn Max-Input leer ist (Slider auf Max), zeige vollen Bereich
         if (maxInput.value === '') {
             displayMin = min;
             displayMax = max;
         } else {
             displayMin = minInput.value; // Sollte Config-Min sein
             displayMax = maxInput.value; // Sollte Slider-Wert sein
         }
         valueDisplay.textContent = `${parseFloat(displayMin)} - ${parseFloat(displayMax)}`;
     }

     // Hilfsfunktion, um alle hidden Inputs basierend auf Slider-Positionen zu aktualisieren
     function updateHiddenInputsFromSliders() {
          filterForm.querySelectorAll('input[type="range"]').forEach(slider => {
              const baseKey = slider.id.replace('-range', '');
              const minInput = document.getElementById(baseKey + '_min');
              const maxInput = document.getElementById(baseKey + '_max');
              const min = parseFloat(slider.getAttribute('min') || 0);
              const max = parseFloat(slider.getAttribute('max') || 0);

              if (minInput && maxInput) {
                  const sliderValue = parseFloat(slider.value);
                  if (sliderValue < max) {
                      minInput.value = min;
                      maxInput.value = sliderValue;
                  } else {
                      minInput.value = '';
                      maxInput.value = '';
                  }
              }
          });
     }

     // Initialen Zustand für History API speichern (nach Initialisierung)
     updateHiddenInputsFromSliders(); // Sicherstellen, dass Inputs korrekt sind
     const initialFormData = new FormData(filterForm);
     const initialFormDataObj = formDataToObject(initialFormData);
     history.replaceState({ formData: initialFormDataObj }, '', window.location.href);

});
</script>
