{# Twig Template für das Auction Filter Modul #}
<div id="auctionFilter" class="mb-0 pt-0 mb-sm-gap {% if class is defined and class %} {{ class }}{% endif %}" style="z-index: 6;">
    <div class="auction-filter-module" data-no-results-text="{{ 'general.no_auctions_for_criteria'|trans|escape('html_attr') }}">
        {# Filter-Formular #}
        <div class="filter-buttons mb-0 mb-sm-4">
            <form class="auction-filter" method="get">
                <div class="row g-1 mb-0 mb-sm-3 justify-content-start"> {# g-2 für kleinen Abstand zwischen den Filter-Buttons #}

                    {# Bestehende Filter als Dropdowns und spezielle Behandlung für isAuctionInFocus #}
                    {% for key, config in filter_configs|default([]) %}
                        {% if key == 'isAuctionInFocus' %}
                            {# Spezielle Behandlung für isAuctionInFocus: Zeige Highlights Button #}
                            <div class="col-auto filter-item-highlights">
                                {# Hidden Input, um den Wert von 'focus' zu senden, gesteuert durch Klick auf den Button #}
                                {# Sicherstellen, dass value='true' nur gesetzt wird, wenn filters.focus exakt der String 'true' ist #}
                                <input type="hidden" name="focus" id="focus_hidden_input" value="{{ filters.focus == 'true' ? 'true' : 'false' }}">
                                <button class="btn {{ filters.focus == 'true' ? 'btn-white' : 'btn-outline-white' }} btn-sm" type="button" id="filterHighlightsButton">
                                    {{ 'filter.highlights_button'|trans }}
                                </button>
                            </div>
                        {% else %}
                            {% set filter_value = filters[key]|default(null) %}
                            {% set filter_value_min = filters[key ~ '_min']|default(null) %}
                            {% set filter_value_max = filters[key ~ '_max']|default(null) %}

                            <div class="col-auto filter-item-{{ key }}">
                                <div class="dropdown">
                                    {% set is_filter_active = false %}
                                    {% if config.type == 'select' %}
                                        {# Für Selects prüfen wir, ob filter_value (jetzt ein String oder null) nicht leer ist #}
                                        {% if filter_value is not null and filter_value != '' %}
                                            {% set is_filter_active = true %}
                                        {% endif %}
                                    {% elseif config.type == 'range_slider' %}
                                        {% if (filters[key ~ '_min'] is not null and filters[key ~ '_min'] != config.min|default(0)) or
                                            (filters[key ~ '_max'] is not null and filters[key ~ '_max'] != config.max|default(100)) %}
                                            {% set is_filter_active = true %}
                                        {% endif %}
                                    {% endif %}

                                    {# Button ist jetzt btn-primary, ggf. mit Indikator für Aktivität #}
                                    <button class="btn btn-white {{ is_filter_active ? 'active' : '' }} dropdown-toggle btn-sm" type="button" id="filterDropdown{{ key|capitalize }}" data-bs-toggle="dropdown" data-bs-auto-close="true" aria-expanded="false">
                                        {{ config.label|trans }}
                                        {% if is_filter_active %}
                                            <span class="badge bg-white text-dark ms-1 rounded-pill">
                                                {% if config.type == 'select' %}
                                                    {# Zähle die Anzahl der ausgewählten Optionen im Kommaseparierten String #}
                                                    {{ filter_value|split(',')|length }}
                                                {% else %}
                                                    !
                                                {% endif %}
                                            </span>
                                        {% endif %}
                                    </button>
                                    {# Dropdown-Menü mit bg-primary text-white #}
                                    <ul class="dropdown-menu bg-primary text-white p-2" aria-labelledby="filterDropdown{{ key|capitalize }}" style="min-width: 310px;">
                                        <li>
                                            {% if config.type == 'select' %}
                                                {% set select_options = options[config.options_key]|default([]) %}
                                                {% set current_values = filter_value is not null ? filter_value|split(',') : [] %}
                                                {% if select_options is not empty %}
                                                    {% for option_value, option_label in select_options %}
                                                        <div class="form-check">
                                                            {# Name ist jetzt ohne [], Wert wird via JS als kommaseparierter String gesammelt #}
                                                            <input class="form-check-input" type="checkbox" name="{{ key }}" value="{{ option_value }}" id="filter_{{ key }}_{{ loop.index }}"
                                                                   {% if option_value in current_values %}checked{% endif %}>
                                                            {# Label-Textfarbe muss ggf. angepasst werden, wenn text-white global ist #}
                                                            <label class="form-check-label small" for="filter_{{ key }}_{{ loop.index }}">
                                                                {{ option_label }}
                                                            </label>
                                                        </div>
                                                    {% endfor %}
                                                {% else %}
                                                    <small class="d-block">{{ 'filter.no_options_available'|trans }}</small> {# text-white greift hier #}
                                                {% endif %}

                                            {% elseif config.type == 'range_slider' %}
                                                {% set min_cfg = config.min|default(0) %}
                                                {% set max_cfg = config.max|default(100) %}
                                                {% set step_cfg = config.step|default(1) %}
                                                {% set current_min_val = filter_value_min|default(min_cfg) %}
                                                {% set current_max_val = filter_value_max|default(max_cfg) %}

                                                <div class="mb-2">
                                                    <div class="d-flex justify-content-between align-items-center mb-1">
                                                        {# Label-Textfarbe #}
                                                        <label class="form-label mb-0 small">{{ config.label|trans }}</label>
                                                        {# Badge-Farbe anpassen #}
                                                        <span id="{{ key }}-range-value" class="badge bg-secondary text-body fw-normal small">
                                                            {% if app.request.locale == 'en' %}
                                                                {{ current_min_val|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, '.', ',') }} - {{ current_max_val|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, '.', ',') }}
                                                            {% else %}
                                                                {{ current_min_val|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, ',', '.') }} - {{ current_max_val|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, ',', '.') }}
                                                            {% endif %}
                                                        </span>
                                                    </div>
                                                    {# Range Slider selbst - das Aussehen wird durch Browser/Bootstrap bestimmt #}
                                                    <div class="mb-1">
                                                        <label for="{{ key }}_min_slider" class="form-label small visually-hidden">{{ 'filter.range.min'|trans }}</label>
                                                        <input type="range" class="form-range form-range-sm" id="{{ key }}_min_slider"
                                                               name="{{ key }}_min"
                                                               min="{{ min_cfg }}"
                                                               max="{{ max_cfg }}"
                                                               step="{{ step_cfg }}"
                                                               value="{{ current_min_val }}">
                                                    </div>
                                                    <div>
                                                        <label for="{{ key }}_max_slider" class="form-label small visually-hidden">{{ 'filter.range.max'|trans }}</label>
                                                        <input type="range" class="form-range form-range-sm" id="{{ key }}_max_slider"
                                                               name="{{ key }}_max"
                                                               min="{{ min_cfg }}"
                                                               max="{{ max_cfg }}"
                                                               step="{{ step_cfg }}"
                                                               value="{{ current_max_val }}">
                                                    </div>
                                                    <div class="d-flex justify-content-between mt-1 small">
                                                        {# Textfarbe für Min/Max Labels #}
                                                        <small class="text-white-50">
                                                            {% if app.request.locale == 'en' %}
                                                                {{ min_cfg|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, '.', ',') }}
                                                            {% else %}
                                                                {{ min_cfg|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, ',', '.') }}
                                                            {% endif %}
                                                        </small>
                                                        <small class="text-white-50">
                                                            {% if app.request.locale == 'en' %}
                                                                {{ max_cfg|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, '.', ',') }}
                                                            {% else %}
                                                                {{ max_cfg|number_format(key in ['irr', 'internalRateOfReturnBeforeRent'] ? 1 : 0, ',', '.') }}
                                                            {% endif %}
                                                        </small>
                                                    </div>
                                                </div>
                                            {% endif %}
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        {% endif %}
                    {% endfor %}


                    {# Prüfe ob irgendwelche Filter aktiv sind #}
                    {% set has_active_filters = false %}

                    {# Prüfe Focus-Filter #}
                    {% if filters.focus == 'true' %}
                        {% set has_active_filters = true %}
                    {% endif %}

                    {# Prüfe andere Filter #}
                    {% if not has_active_filters %}
                        {% for key, config in filter_configs|default([]) %}
                            {% if key != 'isAuctionInFocus' %}
                                {% set filter_value = filters[key]|default(null) %}
                                {% set filter_value_min = filters[key ~ '_min']|default(null) %}
                                {% set filter_value_max = filters[key ~ '_max']|default(null) %}

                                {% if config.type == 'select' %}
                                    {# Für Selects prüfen ob Wert gesetzt und nicht leer #}
                                    {% if filter_value is not null and filter_value != '' %}
                                        {% set has_active_filters = true %}
                                    {% endif %}
                                {% elseif config.type == 'range_slider' %}
                                    {# Für Range Slider prüfen ob Werte von Default abweichen #}
                                    {% if (filter_value_min is not null and filter_value_min != config.min|default(0)) or
                                        (filter_value_max is not null and filter_value_max != config.max|default(100)) %}
                                        {% set has_active_filters = true %}
                                    {% endif %}
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}

                    {% if has_active_filters %}
                        <div class="col-auto ms-auto">
                            {# Buttons mit etwas mehr Abstand oben #}
                            <div class="d-flex gap-2 flex-wrap filter-buttons">
                                {#
                                <button type="submit" class="btn btn-white btn-sm">
                                    {{ 'filter.button.filter'|trans }}
                                </button> #}
                                <a href="{{ app.request.pathInfo }}#auctionFilter" class="btn btn-white btn-sm">
                                    {{ 'filter.button.reset'|trans }}
                                </a>
                                {#
                                <button type="submit" name="refresh" value="1" class="btn btn-danger btn-sm">
                                    {{ 'filter.button.update_data'|trans }}
                                </button>
                                #}
                            </div>
                        </div>
                    {% endif %}

                </div> {# Ende der .row für Filter-Buttons #}


            </form>
        </div>

        {# SPINNER Container wird zum Overlay #}
        <div id="filterSpinnerContainer" class="filter-loading-overlay" style="display: none;">
            {# Das SVG selbst behält seine Klasse für Styling und Animation #}
            <svg class="filter-spinner" style="width: 50px; height: 50px;" viewBox="0 0 45 45" xmlns="http://www.w3.org/2000/svg">
                <g id="spinner">
                    <path d="M24.4874 0.755859H20.9375V18.3459H24.4874V0.755859Z" fill="#113534"/>
                    <path d="M24.4874 37.0078H20.9375V44.268H24.4874V37.0078Z" fill="#113534"/>
                    <path d="M8.15787 20.7324H0.862305V24.265H8.15787V20.7324Z" fill="#113534"/>
                    <path d="M44.5866 20.7324H37.291V24.265H44.5866V20.7324Z" fill="#113534"/>
                    <path d="M40.7669 10.0828L34.4487 13.7129L36.2237 16.7722L42.5418 13.1422L40.7669 10.0828Z" fill="#113534"/>
                    <path d="M31.5313 34.1673L28.457 35.9336L32.1048 42.2211L35.1791 40.4548L31.5313 34.1673Z" fill="#113534"/>
                    <path d="M13.3335 2.80009L10.2593 4.56641L13.9071 10.8539L16.9813 9.08757L13.3335 2.80009Z" fill="#113534"/>
                    <path d="M32.1082 2.76721L28.4604 9.05469L31.5347 10.821L35.1825 4.53352L32.1082 2.76721Z" fill="#113534"/>
                    <path d="M13.9007 34.1676L10.2529 40.4551L13.3272 42.2214L16.975 35.9339L13.9007 34.1676Z" fill="#113534"/>
                    <path d="M4.66946 10.091L2.89453 13.1504L9.21268 16.7805L10.9876 13.7211L4.66946 10.091Z" fill="#113534"/>
                    <path d="M27.2046 23.0488L25.4419 26.1186L34.4512 31.2835L40.743 34.9136L42.5302 31.8438L27.2046 23.0488Z" fill="#113534"/>
                    <path d="M9.21034 28.2381L2.89404 31.8438L4.68121 34.9136L19.9823 26.1186L18.1951 23.0488L9.21034 28.2381Z" fill="#113534"/>
                </g>
            </svg>
        </div>
{#
       <div class="auction-items-placeholder mt-3">
        </div>
#}

    </div>

    {# JavaScript für AJAX-Filter und HTML5 Range Slider #}
    <script>
        window.jsFilterConfigs = JSON.parse('{{ filter_configs|json_encode()|escape("js")|raw }}');

        document.addEventListener('DOMContentLoaded', function () {
            const filterForm = document.querySelector('.auction-filter');
            if (!filterForm) {
                return; // Früher Ausstieg, wenn das Hauptformular fehlt
            }

            const filterModuleElement = document.querySelector('.auction-filter-module');
            const noResultsText = filterModuleElement ? filterModuleElement.dataset.noResultsText : 'Es wurden keine Auktionen für Ihre Filterkriterien gefunden.'; // Fallback-Text

            // Verhindert das Schließen des Dropdowns beim Klicken auf interaktive Elemente im Menü
            document.querySelectorAll('.auction-filter .dropdown-menu').forEach(function (menu) {
                menu.addEventListener('click', function (e) {
                    if (e.target.closest('.form-check-input') || e.target.closest('.form-range')) {
                        e.stopPropagation();
                    }
                });
            });

            // Funktion zur Initialisierung der Range Slider (angepasst für zwei Slider pro Filter)
            function initRangeSlidersNew() {
                filterForm.querySelectorAll('div[class*="filter-item-"]').forEach(filterItem => {
                    const minSlider = filterItem.querySelector('input[type="range"][id$="_min_slider"]');
                    const maxSlider = filterItem.querySelector('input[type="range"][id$="_max_slider"]');
                    const rangeValueDisplay = filterItem.querySelector('[id$="-range-value"]');

                    if (minSlider && maxSlider && rangeValueDisplay) {
                        const updateDisplay = () => {
                            const minValue = parseInt(minSlider.value);
                            const maxValue = parseInt(maxSlider.value);
                            rangeValueDisplay.textContent = `${minValue} - ${maxValue}`;
                        };

                        minSlider.addEventListener('input', () => {
                            if (parseInt(minSlider.value) > parseInt(maxSlider.value)) {
                                maxSlider.value = minSlider.value;
                            }
                            updateDisplay();
                        });

                        maxSlider.addEventListener('input', () => {
                            if (parseInt(maxSlider.value) < parseInt(minSlider.value)) {
                                minSlider.value = maxSlider.value;
                            }
                            updateDisplay();
                        });
                        updateDisplay(); // Initial display
                    }
                });
            }

            initRangeSlidersNew(); // Neue Funktion aufrufen

            // Event Listener für den Highlights-Button
            const highlightsButton = document.getElementById('filterHighlightsButton');
            const highlightsHiddenInput = document.getElementById('focus_hidden_input');

            function bindHighlightButtonListener() {
                const button = document.getElementById('filterHighlightsButton');
                const hiddenInput = document.getElementById('focus_hidden_input');

                if (button && hiddenInput) {
                    // Klonen des Buttons, um alle vorherigen Event-Listener sicher zu entfernen
                    const newButton = button.cloneNode(true);
                    button.parentNode.replaceChild(newButton, button);

                    newButton.addEventListener('click', function () {
                        const currentHiddenInputInClickHandler = document.getElementById('focus_hidden_input');
                        if (!currentHiddenInputInClickHandler) {
                            return;
                        }
                        const currentValue = currentHiddenInputInClickHandler.value;
                        if (currentValue === 'true') {
                            currentHiddenInputInClickHandler.value = 'false';
                            this.classList.remove('btn-white');
                            this.classList.add('btn-outline-white');
                        } else {
                            currentHiddenInputInClickHandler.value = 'true';
                            this.classList.remove('btn-outline-white');
                            this.classList.add('btn-white');
                        }

                        // Zurücksetzen-Button sofort aktualisieren
                        updateResetButton();

                        const formData = new FormData(filterForm);
                        ajaxFilter(formData, true);
                    });
                }
            }

            bindHighlightButtonListener(); // Initial binden
            updateResetButton(); // Initial prüfen

            // Klicks innerhalb des Dropdown-Menüs (auf bestimmte Elemente) sollen es nicht schließen
            document.querySelectorAll('.auction-filter .dropdown-menu').forEach(function (menu) {
                menu.addEventListener('click', function (e) {
                    if (e.target.closest('.form-check-input') ||
                        e.target.closest('.form-range') ||
                        e.target.closest('label') || // Klick auf Label
                        e.target.closest('.dropdown-header')) {
                        e.stopPropagation();
                    }
                });
            });

            const allFilterDropdownToggles = document.querySelectorAll('.auction-filter .col-auto[class*="filter-item-"] .dropdown-toggle');

            allFilterDropdownToggles.forEach(function (toggle) {
                toggle.addEventListener('show.bs.dropdown', function (event) {
                    allFilterDropdownToggles.forEach(function (otherToggle) {
                        if (otherToggle !== event.target) {
                            const dropdownInstance = bootstrap.Dropdown.getInstance(otherToggle);
                            if (dropdownInstance) {
                                dropdownInstance.hide();
                            }
                        }
                    });
                });
            });

            // Globaler Klick-Listener, um Dropdowns zu schließen, wenn außerhalb geklickt wird
            document.addEventListener('click', function (event) {
                const openDropdown = document.querySelector('.auction-filter .dropdown-menu.show');
                if (openDropdown) {
                    const toggleButton = openDropdown.previousElementSibling;
                    // Prüfen, ob der Klick außerhalb des geöffneten Menüs UND außerhalb seines Toggle-Buttons war
                    if (!openDropdown.contains(event.target) && toggleButton && !toggleButton.contains(event.target)) {
                        const dropdownInstance = bootstrap.Dropdown.getInstance(toggleButton);
                        if (dropdownInstance) {
                            dropdownInstance.hide();
                        }
                    }
                }
            });

            function formDataToObject(formData) {
                const object = {};
                const multiSelectValues = {};

                // Manuell den Wert des Hidden Inputs für 'focus' hinzufügen, FALLS er 'true' ist
                if (highlightsHiddenInput && highlightsHiddenInput.value === 'true') {
                    object['focus'] = 'true';
                }

                formData.forEach((value, key) => {
                    if (key === 'focus') return; // Bereits oben behandelt

                    // Leere Werte generell überspringen
                    if (value === null || String(value).trim() === '') {
                        return;
                    }

                    // Range Slider: Nur hinzufügen, wenn nicht Default
                    if (window.jsFilterConfigs && (key.endsWith('_min') || key.endsWith('_max'))) {
                        const baseKey = key.substring(0, key.length - (key.endsWith('_min') ? 4 : 4));
                        const sliderConfig = window.jsFilterConfigs[baseKey];
                        if (sliderConfig) {
                            let isDefault = false;
                            if (key.endsWith('_min') && String(value) === String(sliderConfig.min)) isDefault = true;
                            if (key.endsWith('_max') && String(value) === String(sliderConfig.max)) isDefault = true;
                            if (isDefault) {
                                return; // Nicht ins State-Objekt aufnehmen
                            }
                        }
                    }

                    // Checkboxen für Mehrfachauswahl
                    const formElement = filterForm.elements[key];
                    let isMultiCheckbox = false;
                    if (formElement instanceof NodeList) {
                        isMultiCheckbox = Array.from(formElement).every(el => el.type === 'checkbox');
                    } else if (formElement instanceof HTMLInputElement && formElement.type === 'checkbox') {
                        if (filterForm.querySelectorAll(`input[type="checkbox"][name="${key}"]`).length > 1) {
                            isMultiCheckbox = true;
                        }
                    }

                    if (isMultiCheckbox) {
                        // Potenzielle Mehrfachauswahl-Checkbox
                        if (!multiSelectValues[key]) {
                            multiSelectValues[key] = [];
                        }
                        // Nur gecheckte Werte berücksichtigen. formData enthält für Checkboxen den Wert, wenn sie überhaupt im Formular sind.
                        // Wir müssen hier sicherstellen, dass die spezifische Checkbox auch wirklich aktiv ist.
                        const actualFormElement = formElement instanceof NodeList ? Array.from(formElement).find(cb => cb.value === value && cb.checked) : (formElement.checked ? formElement : null);
                        if (actualFormElement) {
                            if (!multiSelectValues[key].includes(value)) {
                                multiSelectValues[key].push(value);
                            }
                        }
                    } else { // Normale Felder (die nicht leer oder Default-Range sind)
                        // Diese Logik ist für einfache Inputs, die nicht mehrfach vorkommen (z.B. text, oder einzelne selects)
                        // Für Range Slider (_min, _max) ist es bereits oben abgedeckt.
                        if (!key.endsWith('_min') && !key.endsWith('_max')) { // Nicht nochmal für Range Slider
                            if (object.hasOwnProperty(key)) {
                                if (!Array.isArray(object[key])) {
                                    object[key] = [object[key]];
                                }
                                object[key].push(value);
                            } else {
                                object[key] = value;
                            }
                        }
                    }
                });

                // Gesammelte Multi-Select-Werte als kommaseparierte Strings in das Objekt einfügen, wenn nicht leer
                for (const [name, values] of Object.entries(multiSelectValues)) {
                    if (values.length > 0) {
                        object[name] = values.join(',');
                    } else {
                        // Wenn ein multiSelectValues[name] existiert, aber leer ist (sollte nicht passieren durch obige Logik),
                        // dann den Key nicht ins Objekt aufnehmen.
                        // Diese Situation wird eigentlich schon durch `if (values.length > 0)` abgefangen.
                    }
                }
                return object;
            }

            let openDropdownId = null; // Variable, um die ID des geöffneten Dropdowns zu speichern
            const spinnerContainer = document.getElementById('filterSpinnerContainer');

            // Hilfsfunktionen für bessere Übersichtlichkeit
            function updateFilterArea(doc) {
                // Filter-Controls vollständig aktualisieren
                const newFilterControls = doc.querySelector('.auction-filter .row.g-1.mb-3');
                const currentFilterControls = filterForm.querySelector('.row.g-1.mb-3');

                if (newFilterControls && currentFilterControls) {
                    currentFilterControls.innerHTML = newFilterControls.innerHTML;

                    // Event Handler und UI neu initialisieren
                    initRangeSlidersNew();
                    bindHighlightButtonListener();
                    bindDropdownEventHandlers();
                    initBootstrapDropdowns();

                    // Form Event Listeners neu binden
                    rebindFormEventListeners();

                    // Zurücksetzen-Button dynamisch hinzufügen/entfernen
                    updateResetButton();

                    // Dropdown-State wiederherstellen
                    if (openDropdownId) {
                        setTimeout(() => {
                            const dropdownToReopen = document.getElementById(openDropdownId);
                            if (dropdownToReopen) {
                                const bsDropdown = bootstrap.Dropdown.getInstance(dropdownToReopen) || new bootstrap.Dropdown(dropdownToReopen);
                                bsDropdown.show();
                            }
                        }, 50);
                    }
                }
            }

            function checkIfFiltersActive() {
                let hasActiveFilters = false;

                // Debug: Log was wir prüfen
                console.log('Checking if filters are active...');

                // Prüfe Focus-Filter
                const focusInput = document.getElementById('focus_hidden_input');
                if (focusInput && focusInput.value === 'true') {
                    console.log('Focus filter is active:', focusInput.value);
                    hasActiveFilters = true;
                }

                // Prüfe Checkbox-Filter (Select-Filter)
                if (!hasActiveFilters) {
                    const checkboxes = filterForm.querySelectorAll('input[type="checkbox"]:checked');
                    console.log('Checked checkboxes found:', checkboxes.length);
                    if (checkboxes.length > 0) {
                        hasActiveFilters = true;
                    }
                }

                // Prüfe Range-Slider (ob sie von Default-Werten abweichen)
                if (!hasActiveFilters && window.jsFilterConfigs) {
                    console.log('Checking range sliders with configs:', window.jsFilterConfigs);
                    for (const [key, config] of Object.entries(window.jsFilterConfigs)) {
                        if (config.type === 'range_slider') {
                            const minSlider = document.getElementById(`${key}_min_slider`);
                            const maxSlider = document.getElementById(`${key}_max_slider`);

                            if (minSlider && maxSlider) {
                                const minValue = parseInt(minSlider.value);
                                const maxValue = parseInt(maxSlider.value);
                                const defaultMin = config.min || 0;
                                const defaultMax = config.max || 100;

                                console.log(`Range slider ${key}: ${minValue}-${maxValue} vs default ${defaultMin}-${defaultMax}`);

                                if (minValue !== defaultMin || maxValue !== defaultMax) {
                                    console.log(`Range slider ${key} has non-default values`);
                                    hasActiveFilters = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                console.log('Final result - hasActiveFilters:', hasActiveFilters);
                return hasActiveFilters;
            }

            function updateResetButton() {
                const hasActiveFilters = checkIfFiltersActive();

                // Flexiblere Container-Suche
                const filterRow = filterForm.querySelector('.row.g-1') ||
                                 filterForm.querySelector('.row[class*="g-1"]') ||
                                 filterForm.querySelector('.row') ||
                                 filterForm.querySelector('div:first-child');

                let resetButtonContainer = filterForm.querySelector('.col-auto.ms-auto');

                if (hasActiveFilters) {
                    // Zurücksetzen-Button hinzufügen falls nicht vorhanden
                    if (!resetButtonContainer) {
                        resetButtonContainer = document.createElement('div');
                        resetButtonContainer.className = 'col-auto ms-auto';
                        resetButtonContainer.id = 'dynamic-reset-button-container';

                        const resetButtonsDiv = document.createElement('div');
                        resetButtonsDiv.className = 'd-flex gap-2 flex-wrap filter-buttons';

                        const resetLink = document.createElement('a');
                        resetLink.href = `${window.location.pathname}#auctionFilter`;
                        resetLink.className = 'btn btn-white btn-sm';
                        resetLink.textContent = '{{ 'filter.button.reset'|trans }}';

                        resetButtonsDiv.appendChild(resetLink);
                        resetButtonContainer.appendChild(resetButtonsDiv);

                        if (filterRow) {
                            filterRow.appendChild(resetButtonContainer);
                        } else {
                            // Fallback: Container erstellen
                            const fallbackContainer = document.createElement('div');
                            fallbackContainer.className = 'row g-1 mb-3';
                            fallbackContainer.appendChild(resetButtonContainer);

                            const firstRow = filterForm.querySelector('.row');
                            if (firstRow) {
                                firstRow.parentNode.insertBefore(fallbackContainer, firstRow.nextSibling);
                            }
                        }
                    }
                } else {
                    // Zurücksetzen-Button entfernen falls vorhanden
                    if (resetButtonContainer) {
                        resetButtonContainer.remove();
                    }
                }
            }

            function updateListingArea(doc) {
                const newAuctionListingContainer = doc.querySelector('#auction_listing_container');
                const currentAuctionListingContainer = document.querySelector('#auction_listing_container');
                let resultsFound = false;

                if (newAuctionListingContainer && currentAuctionListingContainer) {
                    currentAuctionListingContainer.innerHTML = newAuctionListingContainer.innerHTML;
                    currentAuctionListingContainer.querySelectorAll('[data-animation]').forEach(item => {
                        item.removeAttribute('data-animation');
                    });

                    if (currentAuctionListingContainer.querySelector('.auction-item')) {
                        resultsFound = true;
                    }
                } else {
                    // Fallback für alte Struktur
                    const newItems = doc.querySelector('.auction-items');
                    const newNoItems = doc.querySelector('.no-auctions');
                    const currentItems = document.querySelector('.auction-items');
                    const currentNoItems = document.querySelector('.no-auctions');

                    if (currentItems && newItems && newItems.innerHTML.trim() !== '') {
                        currentItems.innerHTML = newItems.innerHTML;
                        currentItems.style.display = '';
                        if (currentNoItems) currentNoItems.style.display = 'none';
                        currentItems.querySelectorAll('[data-animation]').forEach(item => {
                            item.removeAttribute('data-animation');
                        });
                        if (currentItems.querySelector('.auction-item')) {
                            resultsFound = true;
                        }
                    } else if (currentNoItems && newNoItems) {
                        if (currentItems) currentItems.style.display = 'none';
                        currentNoItems.innerHTML = newNoItems.innerHTML;
                        currentNoItems.style.display = newNoItems.style.display || 'block';
                    }
                }

                // Alert für keine Ergebnisse
                if (!resultsFound) {
                    showNoResultsAlert();
                }

                return resultsFound;
            }

            function resetPaginationIfNeeded(doc) {
                const newPagination = doc.querySelector('.pagination');
                const currentPage = new URLSearchParams(window.location.search).get('page');

                if (currentPage && parseInt(currentPage) > 1 && !newPagination) {
                    // Zur ersten Seite zurückkehren, wenn Paginierung nicht mehr nötig
                    const currentUrl = new URL(window.location);
                    currentUrl.searchParams.delete('page');
                    window.history.replaceState(null, '', currentUrl.toString());
                }
            }

            function showNoResultsAlert() {
                // Alte Alerts entfernen
                document.querySelectorAll('.alert-no-results').forEach(alert => alert.remove());

                const targetContainer = document.querySelector('#auction_listing_container') ||
                                      document.querySelector('.auction-listing') ||
                                      document.querySelector('.auction-filter-module');

                if (targetContainer) {
                    const noResultsAlert = document.createElement('div');
                    noResultsAlert.className = 'alert alert-primary alert-no-results mt-3';
                    noResultsAlert.setAttribute('role', 'alert');
                    noResultsAlert.textContent = noResultsText;
                    targetContainer.appendChild(noResultsAlert);
                }
            }

            function bindDropdownEventHandlers() {
                // Event Listener für Dropdown-Menüs neu binden
                document.querySelectorAll('.auction-filter .dropdown-menu').forEach(function (menu) {
                    menu.addEventListener('click', function (e) {
                        if (e.target.closest('.form-check-input') ||
                            e.target.closest('.form-range') ||
                            e.target.closest('label') ||
                            e.target.closest('.dropdown-header')) {
                            e.stopPropagation();
                        }
                    });
                });
            }

            function initBootstrapDropdowns() {
                // Bootstrap Dropdowns neu initialisieren
                const dropdownToggles = document.querySelectorAll('.auction-filter .dropdown-toggle');
                dropdownToggles.forEach(toggle => {
                    if (!bootstrap.Dropdown.getInstance(toggle)) {
                        new bootstrap.Dropdown(toggle);
                    }
                });

                // Sicherstellen, dass nur ein Dropdown gleichzeitig offen ist
                dropdownToggles.forEach(function (toggle) {
                    toggle.addEventListener('show.bs.dropdown', function (event) {
                        dropdownToggles.forEach(function (otherToggle) {
                            if (otherToggle !== event.target) {
                                const dropdownInstance = bootstrap.Dropdown.getInstance(otherToggle);
                                if (dropdownInstance) {
                                    dropdownInstance.hide();
                                }
                            }
                        });
                    });
                });
            }



            function notifyOtherModules(resultsFound) {
                // Event für andere Module senden
                window.dispatchEvent(new CustomEvent('filterUpdated', {
                    detail: {
                        filters: Object.fromEntries(new FormData(filterForm).entries()),
                        resultsFound: resultsFound
                    }
                }));

                // Auch das Listing-Modul informieren
                const listingModule = document.querySelector('#auction_listing_container');
                if (listingModule) {
                    const updateEvent = new CustomEvent('filterModuleUpdated', {
                        detail: { source: 'filter', resultsFound: resultsFound }
                    });
                    listingModule.dispatchEvent(updateEvent);
                }
            }

            function ajaxFilter(formData, updateUrl = true) {
                // Geöffnetes Dropdown merken
                const openDropdownElement = document.querySelector('.auction-filter .dropdown-menu.show');
                if (openDropdownElement) {
                    const button = openDropdownElement.previousElementSibling;
                    if (button) {
                        openDropdownId = button.id;
                    }
                }

                if (spinnerContainer) {
                    spinnerContainer.style.display = 'flex';
                }

                const processedFormDataForUrl = new FormData();
                const requestBodyFormData = new FormData(filterForm);

                const multiSelectTemp = {};

                const currentFocusHiddenInput = document.getElementById('focus_hidden_input');

                // URL-Parameter: Nur 'focus=true' hinzufügen, wenn aktiv
                if (currentFocusHiddenInput && currentFocusHiddenInput.value === 'true') {
                    processedFormDataForUrl.append('focus', 'true');
                }

                // Original formData (aus dem Argument der Funktion, das vom Button-Klick oder Formular-Change kommt)
                for (const [key, value] of formData.entries()) {
                    if (key === 'focus') continue;

                    // Leere Werte generell überspringen (für Selects, etc.) für die URL
                    if (value === null || String(value).trim() === '') {
                        continue;
                    }

                    // Range Slider: Nur hinzufügen, wenn nicht Default
                    if (window.jsFilterConfigs && (key.endsWith('_min') || key.endsWith('_max'))) {
                        const baseKey = key.substring(0, key.length - (key.endsWith('_min') ? 4 : 4));
                        const sliderConfig = window.jsFilterConfigs[baseKey];
                        if (sliderConfig) {
                            let isDefault = false;
                            if (key.endsWith('_min') && String(value) === String(sliderConfig.min)) isDefault = true;
                            if (key.endsWith('_max') && String(value) === String(sliderConfig.max)) isDefault = true;
                            if (isDefault) {
                                continue;
                            }
                        }
                    }

                    // Checkboxen für Mehrfachauswahl sammeln
                    const formElement = filterForm.elements[key];
                    let isMultiCheckboxSource = false;
                    if (formElement instanceof NodeList) {
                        isMultiCheckboxSource = Array.from(formElement).every(el => el.type === 'checkbox');
                    } else if (formElement instanceof HTMLInputElement && formElement.type === 'checkbox') {
                        if (filterForm.querySelectorAll(`input[type="checkbox"][name="${key}"]`).length > 1) {
                            isMultiCheckboxSource = true;
                        }
                    }

                    if (isMultiCheckboxSource) {
                        if (!multiSelectTemp[key]) {
                            multiSelectTemp[key] = [];
                        }
                        const checkboxElement = formElement instanceof NodeList ? Array.from(formElement).find(cb => cb.value === value) : formElement;
                        if (checkboxElement && checkboxElement.checked) {
                            if (!multiSelectTemp[key].includes(value)) {
                                multiSelectTemp[key].push(value);
                            }
                        }
                    } else {
                        // Für alle anderen Felder direkt übernehmen (die nicht leer oder Default-Range sind)
                        processedFormDataForUrl.append(key, value);
                    }
                }

                // Die gesammelten Multi-Select-Werte als kommaseparierte Strings hinzufügen, wenn nicht leer
                for (const [name, values] of Object.entries(multiSelectTemp)) {
                    if (values.length > 0) {
                        processedFormDataForUrl.append(name, values.join(','));
                    }
                }

                const params = new URLSearchParams(processedFormDataForUrl);
                const currentPath = window.location.pathname;
                const queryString = params.toString();
                const newUrl = currentPath + (queryString ? '?' + queryString : '');

                if (updateUrl) {
                    const stateObject = formDataToObject(new FormData(filterForm));
                    history.pushState({formData: stateObject}, '', newUrl);
                }

                // Für den eigentlichen Fetch-Request verwenden wir requestBodyFormData,
                // die ALLE aktuellen Filterwerte (inkl. focus=false, default range slider werte etc.) enthält,
                // damit der Controller und Service die korrekte Filterlogik anwenden können.
                // Der Server entscheidet dann, was gefiltert wird.
                // Die URL ist nur zur "kosmetischen" Anzeige und zum Teilen da.

                fetch(newUrl, {
                    method: 'GET',
                    headers: {'X-Requested-With': 'XMLHttpRequest'}
                })
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}, message: ${response.statusText}`);
                        return response.text();
                    })
                    .then(html => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');

                        // 1. Filter-Bereich vollständig aktualisieren
                        updateFilterArea(doc);

                        // 2. Listing-Bereich vollständig aktualisieren
                        const resultsFound = updateListingArea(doc);

                        // 3. Paginierung bei Bedarf zurücksetzen
                        resetPaginationIfNeeded(doc);

                        // 4. URL aktualisieren
                        if (updateUrl) {
                            window.history.pushState(null, '', newUrl.toString());
                        }

                        // 5. Events für andere Module senden
                        notifyOtherModules(resultsFound);

                    })
                    .catch(error => {
                        console.error('Filter-Fehler:', error);
                        // Fallback: vollständiger Reload
                        if (updateUrl) {
                            window.location.href = newUrl;
                        }
                    })
                    .finally(() => {
                        if (spinnerContainer) {
                            spinnerContainer.style.display = 'none';
                        }
                        // Dropdown wieder öffnen, falls eines offen war
                        if (openDropdownId) {
                            const dropdownButton = document.getElementById(openDropdownId);
                            if (dropdownButton) {
                                const bsDropdown = bootstrap.Dropdown.getInstance(dropdownButton) || new bootstrap.Dropdown(dropdownButton);
                                bsDropdown.show();
                            }
                            openDropdownId = null;
                        }
                    });
            }

            filterForm.addEventListener('submit', function (event) {
                event.preventDefault();
                const formData = new FormData(filterForm);
                ajaxFilter(formData);
            });

            // Event Listener für Änderungen an den Filter-Elementen für "live" Filterung WIEDER AKTIVIERT
            filterForm.addEventListener('change', function (event) {
                // Prüfen, ob die Änderung von einem relevanten Filterelement stammt
                // (nicht der Highlights-Button, der seinen eigenen Listener hat)
                if (event.target.id !== 'filterHighlightsButton' &&
                    (event.target.matches('.form-check-input') || event.target.matches('input[type="range"]'))) {
                    // Zurücksetzen-Button sofort aktualisieren
                    updateResetButton();

                    const formData = new FormData(filterForm);
                    ajaxFilter(formData, true);
                }
            });

            // Event Listener für Input-Events (Range Slider während dem Ziehen)
            filterForm.addEventListener('input', function (event) {
                if (event.target.matches('input[type="range"]')) {
                    // Zurücksetzen-Button bei Range-Slider Änderungen aktualisieren
                    updateResetButton();
                }
            });

            window.addEventListener('popstate', function (event) {
                const formDataFromState = (event.state && event.state.formData) ? event.state.formData : {};

                // Setze alle Formularfelder auf Basis des States zurück oder auf Default
                filterForm.querySelectorAll('input, select').forEach(el => {
                    const nameInState = el.name;
                    const stateValue = formDataFromState[nameInState]; // Kann undefined sein

                    if (el.type === 'checkbox') {
                        if (el.name === 'focus') {
                            // focus ist speziell, da es nicht in der main iteration von formDataFromState ist, wenn false
                            el.checked = (formDataFromState.focus === 'true');
                        } else { // Andere Checkboxen (potenziell Multi-Select)
                            if (typeof stateValue === 'string' && stateValue) { // Wert ist kommaseparierter String und nicht leer
                                el.checked = stateValue.split(',').includes(el.value);
                            } else {
                                el.checked = false; // Nicht im State oder leer -> nicht gecheckt
                            }
                        }
                    } else if (el.type === 'range') {
                        const baseKey = el.name.substring(0, el.name.length - (el.name.endsWith('_min') ? 4 : 4));
                        const sliderConfig = window.jsFilterConfigs ? window.jsFilterConfigs[baseKey] : null;

                        if (sliderConfig) {
                            if (el.name.endsWith('_min')) {
                                el.value = stateValue !== undefined ? stateValue : sliderConfig.min;
                            } else if (el.name.endsWith('_max')) {
                                el.value = stateValue !== undefined ? stateValue : sliderConfig.max;
                            }
                        } else { // Fallback, falls Config nicht da ist (sollte nicht passieren)
                            el.value = stateValue !== undefined ? stateValue : el.defaultValue;
                        }
                    } else if (el.type === 'hidden' && el.name === 'focus') { // Hidden Input für Focus
                        el.value = formDataFromState.focus === 'true' ? 'true' : 'false';
                    } else { // Andere Input-Typen (z.B. theoretische Text-Inputs oder einzelne Selects)
                        el.value = stateValue !== undefined ? stateValue : ''; // Default auf leer
                    }
                });

                // Range Slider UI aktualisieren
                initRangeSlidersNew();

                // Highlight-Button UI aktualisieren
                const currentHighlightButton = document.getElementById('filterHighlightsButton');
                const focusHidden = document.getElementById('focus_hidden_input'); // Der Wert wurde gerade durch die Schleife oben gesetzt
                if (currentHighlightButton && focusHidden) {
                    const isFocusActive = focusHidden.value === 'true';
                    currentHighlightButton.classList.toggle('btn-white', isFocusActive);
                    currentHighlightButton.classList.toggle('btn-outline-white', !isFocusActive);
                }

                // Zurücksetzen-Button nach popstate aktualisieren
                updateResetButton();

                // AJAX-Filterung auslösen, ohne neuen History-Eintrag
                const currentFormDataForAjax = new FormData(filterForm); // Hole aktuelle Werte aus dem Formular
                ajaxFilter(currentFormDataForAjax, false); // false, um keinen neuen History-Eintrag zu pushen
            });
        });
    </script>

</div>

